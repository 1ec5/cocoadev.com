Describe [[WSMakeStubsWSGenerateObjCallingASPNETWebservice]] here.



To set this up, I have an ASP.NET webservice written in C# with the
default namespace of tempuri.org and I have Cocoa stubs generated by
[[WSMakeStubs]]. I encountered several problems getting this working as listed below.

Problem 1 - failure to call asp.net webservice
I had to make a couple of changes to make this work - both documented in
other places. First of all, the soapAction and methodNamespace were
missing in the generated stub file. Also, the kWSSOAPBodyEncodingStyle
value was wrong:-

Original code:
<code>
 - (WSMethodInvocationRef) genCreateInvocationRef {
     return [self createInvocationRef
     /*endpoint*/:@"http://172.16.1.108/MyWebService/Service1.asmx"
       methodName: @"DoSomething"
         protocol: (NSString*) kWSSOAP2001Protocol
      // missing encoding style - defaulting to RPC
           style: (NSString*) kWSSOAPStyleRPC
       soapAction: nil /* No SOAPAction header needed */
 methodNamespace: NULL /* No Method Namespace specified */
 ];
 }
</code>
Modified code:
<code>
 - (WSMethodInvocationRef) genCreateInvocationRef {
     return [self createInvocationRef
     /*endpoint*/:@"http://172.16.1.108/MyWebService/Service1.asmx"
       methodName: @"DoSomething"
         protocol: (NSString*) kWSSOAP2001Protocol
            style: (NSString*) kWSSOAPStyleDoc // CHANGED
       soapAction: @"http://tempuri.org/DoSomething" // CHANGED
  methodNamespace: @"http://tempuri.org/" // CHANGED important - don't forget the trailing forward slash
 ];
 }
</code>
Also, .NET requires a SOAP action so the [[WSGeneratedObj]].m file needs to
be modified to work correctly. The name of the locally declared variable
'soapAction' conflicts with the parameter passed in with the same name:

Original code:
<code>
 NSString* soapAction = @"SOAPAction";
 NSDictionary* headers = [self copyHeaderDictionary:1 extraVals:&soapAction extraKeys:&soapAction];
</code>
Modified code:
<code>
 NSString* soapActionKey = @"SOAPAction";
 NSDictionary* headers = [self copyHeaderDictionary:1 extraVals:&soapAction extraKeys:&soapActionKey];
</code>
At this stage, I can call my ASP.NET web service and retrieve a result
as expected.


Problem 2 - each web service call results in a memory leak

This took a while to find but it turns out the [[WSGeneratedObj]] dealloc
never gets called because its retain count doesn't reach 0. The reason
for this is that the [[WSMethodInvocationSetCallBack]] call towards the end
of the createInvocationRef method in [[WSGeneratedObj]] increments the
retain count. This method sets the callback for the asynchronous web
service call. The documentation for this method states that you should
call the method again passing in NULL for the second and third
parameters to clear the invocation. I added this extra call at the end
of getResultDictionary in [[WSGenenratedObj]] to decrement the retain
count:-
<code>
 if(fRef) { // new code
     WSMethodInvocationSetCallBack(fRef, NULL, NULL); // new code
 } // new code
 return fResult; // original code
</code>
Now the dealloc is called correctly when the invocation object is
released in the generated stub.

Problem 3 - application crashes now dealloc is called

Now dealloc is called and the object various objects are released
correctly, but I get a crash in [[NSPopAutoreleasePool]] indicating that an
object is being over-released somewhere. I tracked this down to (I
think) the extra release of the [[NSURL]] in createInvocationRef in
[[WSGeneratedObj]]. It is my understanding that this returns an autoreleased
object:-
<code>
 NSURL* url = [NSURL URLWithString: endpoint];
 if (url == NULL) {
   [self handleError: @"NSURL URLWithString failed in createInvocationRef" errorString:NULL
        errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:paramErr];
 } else {
   ref = WSMethodInvocationCreate((CFURLRef) url, (CFStringRef)methodName, (CFStringRef) protocol);
      // [url release]; remove this line
   ....
</code>